
Stack----
    High
     |    
     |    <caller function's stack>
     |    
     |    param  x
     |    param ...
     |    param  1
     |    param  0
     |    
     |    <$sp when enter function>
     |    
     |    local  x
     |    local ...
     |    local  1          <Note: local and temp can be mixed.>
     |    local  0
     |    
     |    temp   x
     |    temp  ...
     |    temp   1
     |    temp   0
     |    
     |    $ra
     |    
     |    $s0
     |    $s1
     |    $s...
     |    $sx
     |    
     |    <$sp before starting function exectuing>
     |    
     â†“    
    Low


DataCmd----

    * Three kinds of labels:
        1. jump labels: two kinds
            a. function label
            b. auto-generaterd label
        2. var labels: all global varaibles
        3. string labels: use string table to save map relations.
    * in .data segament, var labels & string labels need to be declared.

    [string labels]
        <name>: .asciiz "<string>"
            * label name is auto_generated, called <name>
            * the label's corresponding string is called <string>

    [var labels] [dim == 0]
        <name>: .word
            * label name is transformed from var's name, called <name>
            * Both char and int are using one word, only cutting tail when saving into memory.

    [var labels] [dim > 0]
        <name>: .space 4*<dim>
            * label name is the same as var labels with 0 dim.
            


InstCmd----

    Following is Tuple-MIPS 's mapping relation.
        * All assumes values are registers or intermediate values.
            global variable is an expection, we use its label format.
        * For char type, we just save/load one byte when saving/loading the char var.
            After it is loaded into memory, we operate as a int.
            For a char array, each element is aligned to one word in memory.
            All char element is save in one word in memory.
        * For each map, allow one temp register. Represented by $T
        * For a string, use its label.

    EMPTY
        nop

    LABEL<Not function>
        left:

    ASSIGN
        move res, left

    NEG
        neg res, left

    ADD, SUB, MUL, DIV
        add/sub/mul/div res, left, right

    WARRAY
        sll $T, left, 2
        sw  right, res($T)

    RARRAY
        sll $T, right, 2
        lw  res, left($T)

    FUNC
        <stack_size>: local vars & GPR saved area.
        left.name:
        add $sp, $sp, -<stack_size>
        sw  $ra, xxx($sp)
        sw  $s?, xxx($sp)
        ...
        sw  $s0, 0($sp)

    PARAM
        add $sp, $sp, -4
        sw  res, 0($sp)
        # add <param_count>

    CALL
        jal res
        add $sp, $sp, 4*<param_count>

    RET
        <stack_size>: local vars & GPR saved area.
        lw  $s0, 0($sp)
        ...
        lw  $s?, xxx($sp)
        lw  $ra, xxx($sp)
        add $sp, $sp, <stack_size>
        jr  $ra

    INPUT
        <sys_num-- 
            char: 12
            int: 5
            >
        li  $v0, <sys_num>
        syscall
        move res, $v0

    OUTPUT
        * if left is set,
            la  $a0, left
            li  $v0, 4
            syscall
        * if right is set,
            <sys_num-- 
                char: 11
                int: 1
                >
            li  $v0, <sys_num>
            syscall

    LESS, LESSOREQUAL, MORE, MOREOREQUAL, NOEQUAL, EQUAL
        slt/sle/sgt/sge/sne/seq res, left, right

    BEZ
        beqz left, res

    BEQ
        beq left, right, res

    JMP
        j res